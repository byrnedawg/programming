{"filter":false,"title":"m19A1.c","tooltip":"/avr/m19A1/m19A1.c","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":325,"column":1},"action":"insert","lines":["/*"," * M19A1.c"," *"," * Created: 8/13/2015 8:32:47 AM"," *  Author: gregory.byrne"," */ ","","#define F_CPU 1000000UL","#include <avr/io.h>","#include <avr/interrupt.h>","#include <avr/sleep.h>","#include <util/atomic.h>","#include <util/delay.h>","#include <stdbool.h>","","//\t\t\t\t\t\t\t\t\t\t\t\t   ______","//\t(PCINT5/~RESET/ADC0/dW)\t\t\tReset\t--PB5 |\t\t |VCC--\t5V","//\t(PCINT3/XTAL1/CLKI/~OC1B/ADC3)\tBatt\t--PB3 |\t\t |PB2--\tSwitch\t\t\t\t\t\t(SCK/USCK/SCL/ADC1/T0/INT0/PCINT2)","//\t(PCINT4/XTAL2/CLKO/OC1B/ADC2) Latch On \t--PB4 |\t\t |PB1--\t10K -- N-Chann Mosfett Gate\t(MISO/DO/AIN1/OC0B/OC1A/PCINT1)","//\t\t\t\t\t\t\t\t\t\t\t--GND |______|PB0--\tAux PWM\t\t\t\t\t\t(MOSI/DI/SDA/AIN0/OC0A/~OC1A/AREF/PCINT0)","//","","#define sbi(x,y) x |= _BV(y) //set bit (original sbi)","#define cbi(x,y) x &= ~(_BV(y)) //(original)cbi clear bit //reverse cause of 3904","#define tbi(x,y) x ^= _BV(y) //toggle bit","#define is_high(x,y) (x & _BV(y)) == _BV(y) //(for input) checks if the // input is high (Logic 1) i.e. if(is_high(PIND,PD0))","#define RESET &=~","#define SET |=","#define TOGGLE ^=","#define PWM_200Hz 0x27   //timer 1 OCR1C = PWM_200Hz;","#define PWM_30Hz 0xFC\t//timer 1 OCR1C = PWM_30Hz;","","volatile uint8_t switch_state;\t// Light Function state","volatile uint8_t last_switch_state; //Stores the last switch state for light wake up","volatile uint8_t Led_Strip_Brightness; // red pwm duty cycle","volatile uint8_t Power_Latch; // blue pwm duty cycle","volatile uint8_t Aux_PWM; // green pwm duty cycle","volatile uint8_t Light_On_Threshold; // Light on variable for analog digital converter","volatile uint16_t Sensor_Sample_Rate; // Controls the frequency the read ADC is called for the LDR","volatile uint16_t timer0Overflows; // Stores the value for timer polling timer 0","volatile uint16_t timer1Overflows; // Stores the value for timer polling timer 1","volatile uint16_t LDR_Value; // Value the ADC reads on the LDR pin PB3","volatile uint16_t Auto_Off_Seconds;","volatile uint16_t Auto_Off_Timer;","volatile uint16_t Auto_Off_Sample_Rate;","volatile bool Light_on; // true if LDR_Value > Light_On_Threshold","volatile bool BTN_Down; // true if the push button is being help down","","ISR(ANA_COMP_vect)","{","","}","","ISR(ADC_vect) // Interrupt for ADC Converter","{","\tuint8_t temp; // raw a2d variable","\ttemp = ADCH ; // ADCH is the high portion of the a2d","\tLDR_Value = (56 * 255 / temp); // 56/ 1.1v = 255/5v (5v/wanted voltage level = 255/ 8 bit quantized voltage","","\t//if(LDR_Value > Light_On_Threshold) //132/2.6V Low Battery Voltage divider R1 324Ohms R2 200","\tif(LDR_Value > Light_On_Threshold) //250","\t{","\t\tLight_on = true; // light should power on cause the LDR is reading it is dark","\t}","\telse","\t{","\t\tLight_on = false; // LDR senses light","\t\tif(switch_state != 0) // If light is on","\t\t{","\t\t\tif(switch_state == 9) // If light is on but in the off mode","\t\t\t{","\t\t\t\tlast_switch_state = 1; // store switch state as red so when it is dark again the unit powers on with a light and not in the off mode","\t\t\t}","\t\t\telse","\t\t\t{","\t\t\t\tlast_switch_state = switch_state; // store the previous light state so when it is dark again the correct mode powers up","\t\t\t}","\t\t}","\t\tswitch_state = 0; // set to power off state because of light detected","\t}","","}","","ISR(TIMER0_OVF_vect) // timer 0 overflow interrupt","{","\ttimer0Overflows++;\t// 225 1 min // 1125 5 min // 2250 10min // 15 4seconds // keep track of timer 0 overflows for timer interrupt polling","\tif((timer0Overflows % 5) == 0) //15 4 seconds","\t{","\t\tif(switch_state == 0 && Light_on == true) // if the light is off and its supposed to be on","\t\t{","\t\t\tswitch_state = last_switch_state; // restore previous powered on switch state","\t\t\tlast_switch_state = 1; // set last switch state to 1","\t\t}","\t\tif(switch_state == 1)\t//Red","\t\t{","\t\t\tLed_Strip_Brightness = 51; // **** NOTE: Red and green should be switched and for there timer 0 is 100% and 255 is 0%","\t\t\tAux_PWM = 0;","\t\t\tPower_Latch = 255;  // **** NOTE: for blue 0 is 0% and 255 is 100%","\t\t}","\t\telse if(switch_state == 2)\t//Orange","\t\t{","\t\t\tLed_Strip_Brightness = 102; //245","\t\t\tAux_PWM = 0; //165","\t\t\tPower_Latch = 255;","\t\t}","\t\telse if(switch_state == 3)\t//Yellow","\t\t{","\t\t\tLed_Strip_Brightness = 153; //40 is less brighter than 0","\t\t\tAux_PWM = 0; //40 is less brighter than 0","\t\t\tPower_Latch = 255;","\t\t}","\t\t","\t\telse if(switch_state == 4)\t//Green","\t\t{","\t\t\tLed_Strip_Brightness = 204;","\t\t\tAux_PWM = 0;","\t\t\tPower_Latch = 255;","\t\t}","\t\telse if(switch_state == 5)\t//Blue","\t\t{","\t\t\tLed_Strip_Brightness = 255;","\t\t\tAux_PWM = 0;","\t\t\tPower_Latch = 255;","\t\t}","\t\telse if(switch_state == 6)\t//Blue","\t\t{","\t\t\tLed_Strip_Brightness = 0;","\t\t\tAux_PWM = 0;","\t\t\tPower_Latch = 0;","\t\t}","\t\telse if(switch_state == 0)\t//Light detected OFF","\t\t{","\t\t\tLed_Strip_Brightness = 0;","\t\t\tAux_PWM = 0;","\t\t\tPower_Latch = 0;","\t\t\tswitch_state = 0;","\t\t}","\t\telse","\t\t{","\t\t\t","\t\t\tswitch_state = 0; // set switch state to 0 if the state is above 9","\t\t\t","\t\t}","\t\t","\t\tOCR0B = (255 - Led_Strip_Brightness);  // PWM Duty cycle value","\t\tOCR0A = (255 - Aux_PWM); // PWM Duty cycle value switched green and red","\t\tOCR1B = Power_Latch; // PWM Duty cycle value","\t}","","\tif((timer0Overflows % Sensor_Sample_Rate) == 0) //  Sensor_Sample_Rate = %500","\t{","\t\tADCSRA|=(1<<ADSC); // setting ADSC to 1 starts A2D Conversion","\t\tif(Light_on == false) // return from A2D interrupt check if the light should be on","\t\t{","\t\t\tswitch_state = 0; // if light should be off set to state 0 or the off state","\t\t}","\t\t","\t}","\t","\tif((timer0Overflows % Auto_Off_Sample_Rate) == 0) //  Sensor_Sample_Rate = %500","\t{\t","\t\tif(Auto_Off_Timer >= Auto_Off_Seconds) // Value in Seconds","\t\t{","\t\t\tswitch_state = 6; // if light should be off set to state 0 or the off state","\t\t\tAuto_Off_Timer = 0;","\t\t}","\t\telse","\t\t{","\t\t\tAuto_Off_Timer++;","\t\t}","\t\t","\t}","","\t","}","ISR(TIMER0_COMPA_vect) // timer 0 compare A interrupt","{","\t","}","","ISR(TIMER0_COMPB_vect) // timer 0 compare B interrupt","{","","}","","ISR(TIMER1_OVF_vect) // timer 1 overflow interrupt","{","\ttimer1Overflows++; //keep track of timer 1 overflows for timer interrupt polling","\t","\tif((timer1Overflows % 20) == 0) // push button polling 195 1 sec /975 5 sec/ 11700 1 min/","\t{","\t\tif(bit_is_clear(PINB, 2)) // if the push button is held down connecting pin B2 to ground","\t\t{","\t\t\tBTN_Down = true; // button down is true","\t\t\tAuto_Off_Timer = 0;","\t\t}","\t}","\tif((timer1Overflows % 25) == 0) // push button polling on the release","\t{","","\t\tif(bit_is_set(PINB, 2) && BTN_Down) // push button release to set pin B2 to high again after being held low","\t\t{","\t\t\t//sbi(PORTB,PB3);","\t\t\tswitch_state++; // increment mode states by 1 i.e. red -> yellow, green - > blue","\t\t\tlast_switch_state = switch_state; // update the last switch state to hold the value of switch state in case of a light power down","\t\t\tBTN_Down = false; // push button is released so the button is no longer held down","\t\t\tAuto_Off_Timer = 0;","\t\t}","\t}","\t","}","","","","ISR(TIMER1_COMPA_vect) // timer 1 compare A interrupt","{","","}","","ISR(TIMER1_COMPB_vect) // timer 1 compare B interrupt","{","","}","","ISR(PCINT0_vect) // Pin Change interrupt service routine","{","\tsleep_disable(); // If pins change state wake up","\tTCNT0 = 0x00; // reset timer 0","\tTCNT1 = 0x00; // reset timer 1","\ttimer0Overflows = 0; // reset timer o overflows","\t//timer1Overflows = 0; // dont reset timer 1 overflows keep running forever","}","","void PortInit(void) // initialize port B inputs and outputs","{","\t//\t\t\t\t\t\t\t\t\t\t\t\t   ______","\t//\t(PCINT5/~RESET/ADC0/dW)\t\t\tReset\t--PB5 |\t\t |VCC--\t5V","\t//\t(PCINT3/XTAL1/CLKI/~OC1B/ADC3)\tLDR\t\t--PB3 |\t\t |PB2--\tSwitch\t(SCK/USCK/SCL/ADC1/T0/INT0/PCINT2)","\t//\t(PCINT4/XTAL2/CLKO/OC1B/ADC2)\tBLU LED\t--PB4 |\t\t |PB1--\tRED LED\t(MISO/DO/AIN1/OC0B/OC1A/PCINT1)","\t//\t\t\t\t\t\t\t\t\t\t\t--GND |______|PB0--\tGRN LED\t(MOSI/DI/SDA/AIN0/OC0A/~OC1A/AREF/PCINT0)","\t//","","\tPORTB = (1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB1)|(1<<PB0); // set all pins we are using high","\tDDRB = (1<<DDB4)|(0<<DDB3)|(0<<DDB2)|(1<<DDB1)|(1<<DDB0); // set PB4, PB1 and PB0 as outputs and PB3 and PB2 as inputs","\tPORTB = (0<<PB4)|(0<<PB1)|(0<<PB0); // set all outputs to 0","}","","void SystemInit(void) // Power on variable initialization","{","\tLight_on = true; // initialize the light to be powered on","\tAuto_Off_Sample_Rate = 500; // 500 with 60 seconds almost exactly 1 min","\tAuto_Off_Seconds = 90;  // 60 with 500 sample rate almost exactly 1 min","\tSensor_Sample_Rate = 1000; // set Auto Off and ADC read speed to 500 is about 1 second","\tLight_On_Threshold = 250; // set LDR > Light_On_Threshold = 250","\tOCR1C = PWM_200Hz; // set PWM for timer 1 to 200 hz","\tswitch_state = 1; // set to state 1 which is red","\tlast_switch_state = switch_state; // initialize last switch state to red","\tLed_Strip_Brightness = 51; // red values","\tAux_PWM = 0; // red values","\tPower_Latch = 255; // red values","\tOCR0B = (255 - Led_Strip_Brightness); // red values","\tOCR0A = (255 - Aux_PWM); // red values","\tOCR1B = Power_Latch; // red values","\t","\tBTN_Down = false; // button is not pushed down","\tPCMSK |= (1<<PCINT2); // pin change mask: listen to portb bit 2 PB2","\tGIMSK |= (1<<PCIE); // enable PCINT interrupt","\tMCUCR |= (1<<BODS)|(0<<PUD)|(1<<SE)|(0<<SM1)|(1<<SM0)|(0<<BODSE)|(1<<ISC01)|(0<<ISC00); // disable BOD during sleep, Sleep Enable, ADC Noise Reduction, The falling edge of INT0 generates an interrupt request","\tsei(); // enable all interrupts","\ttimer0Overflows = 0; // time0roverflows set to 0","\ttimer1Overflows = 0; // time1roverflows set to 0","}","","void timer0_init(void) // Initialize timer 0","{","\t// NOTE: Assumes DIV8 fuse set for 1 MHz operation","\t// 8-bit counter means overflow interrupt every 61 Hz to turn on the LED","\t// Variable Compare_A interrupt in between OVF to turn off the LED","\tTCCR0A |= (1<<COM0A1)|(1<<COM0A0)|(1<<COM0B1)|(1<<COM0B0)|(1<<WGM01)|(1<<WGM00); // Set OC0A/OC0B on Compare Match, clear OC0A/OC0B at BOTTOM (inverting mode) ,Fast PWM Mode","\tTCCR0B |= (0<<FOC0A)|(0<<FOC0B)|(0<<WGM02)|(0<<CS02)|(1<<CS01)|(0<<CS00); //0x02;\tpre-scale= CK/8","\tOCR0A = 0x00; // Governs Duty Cycle (192 ~75% of 256) for inverting mode OCR0A = (255-duty-cycle)","\tOCR0B = 0x00; // Governs Duty Cycle (192 ~75% of 256) for inverting mode OCR0B = (255-duty-cycle)","\tTCNT0 = 0x00; // Start Timer","\ttimer0Overflows = 0; // Start timer overflows at 0","}","","void timer1_init(void) // Initialize timer 1","{","\tTCCR1 |= (0<<CTC1)|(0<<PWM1A)|(0<<COM1A1)|(0<<COM1A0)|(1<<CS13)|(0<<CS12)|(0<<CS11)|(0<<CS10); // PWM1A Disabled, Timer/Counter Comparator A disconnected from output pin OC1A, prescale= CK/128 right now was CK/8 1000b ~ 1100b","\tGTCCR |= (0<<TSM)|(1<<PWM1B)|(1<<COM1B1)|(0<<COM1B0)|(0<<FOC1B)|(0<<FOC1A)|(0<<PSR1)|(0<<PSR0); //PWM1B Enabled, OC1B cleared on compare match. Set when TCNT1 = $00","\t//OCR1A = 0x00; // Disabled Governs Duty Cycle (128 ~50% of 256)","\tOCR1B = 0x00; // Governs Duty Cycle (192 ~75% of 256)","\tOCR1C = PWM_200Hz;\t// OCR1C = Governs PWM Frequency :: (1Mhz/prescaler)/(OCR1C+1)= PWM Frequency :: 1M/128/39+1 = 200Hz\t0x27 1M/128/252+1 = 33Hz\t0xFC","\tTIMSK |= (0<<OCIE1A)|(1<<OCIE1B)|(0<<OCIE0A)|(0<<OCIE0B)|(1<<TOIE1)|(1<<TOIE0);\t// Compare A and OVF Interrupt enabled","\tTCNT1 = 0x00; // Start Timer","\ttimer1Overflows = 0; // Start timer overflows at 0","}","","void Analog_Comparator_init(void) // Initialize Analog Comparator","{","\tADCSRB |= (0<<BIN)|(0<<ACME)|(0<<IPR)|(0<<ADTS2)|(0<<ADTS1)|(0<<ADTS0); //Analog Comparator Multiplexer Enable","\tACSR |= (0<<ACD)|(0<<ACBG)|(0<<ACO)|(0<<ACI)|(0<<ACIE)|(0<<ACIS1)|(0<<ACIS0); // Analog Comparator Control Register","\tDIDR0 |= (0<<ADC0D)|(0<<ADC2D)|(0<<ADC3D)|(0<<ADC1D)|(0<<AIN1D)|(0<<AIN0D); // Digital input Disable Register","}","","void ADC_init(void) // Initialize Analog to Digital Converter","{","\tADMUX |= (0<<REFS1)|(0<<REFS0)|(1<<ADLAR)|(0<<REFS2)|(0<<MUX3)|(0<<MUX2)|(1<<MUX1)|(1<<MUX0); //ADC Multiplexer Selection Register... (ADC3(PB3) Selected ADC Input)","\tADCSRA |= (1<<ADEN)|(1<<ADSC)|(0<<ADATE)|(0<<ADIF)|(1<<ADIE)|(0<<ADPS2)|(0<<ADPS1)|(0<<ADPS0); // ADC Control Register A","\tADCSRB |= (0<<BIN)|(0<<ACME)|(0<<IPR)|(0<<ADTS2)|(0<<ADTS1)|(0<<ADTS0); // ADC Control Register B","\tDIDR0 |= (0<<ADC0D)|(0<<ADC2D)|(0<<ADC3D)|(0<<ADC1D)|(0<<AIN1D)|(0<<AIN0D); // Digital input Disable Register","}","","int main(void)","{","\ttimer0_init(); // timer 0 initialize","\ttimer1_init(); // timer 1 initialize","\tADC_init(); // analog to digital converter initialize","\tPortInit(); // inputs and outputs initialize","\tSystemInit(); // system variables and state initialize","","\twhile(1)","\t{","\t\tsleep_enable(); // sleep until pin interrupt","\t}","}"],"id":1}]]},"ace":{"folds":[],"scrolltop":1620,"scrollleft":0,"selection":{"start":{"row":144,"column":12},"end":{"row":144,"column":12},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":107,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1475149353507,"hash":"72bb5864b05ccb7b33d05d6decb9461e7967942d"}